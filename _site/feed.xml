<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-26T20:48:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">leo-labbb DEVLOG</title><subtitle>awesome world</subtitle><author><name>이승호</name></author><entry><title type="html">[REACT] 리액트 value 에러 / e.persist();</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="[REACT] 리액트 value 에러 / e.persist();" /><published>2022-07-26T00:00:00+09:00</published><updated>2022-07-26T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p>리액트에서의 onChange , onClick 등에 들어오는 event 파라미터는
브라우저에서 사용되고있는 Event 인
Event와는 다른 객체이다.</p>

<p>해당 event 객체는 리액트에서 작성한 SyntheticEvent로 웹 브라우저에 있는 Event를 이용한 새로운 객체입니다.
그렇기 때문에 위의 비동기 처리시에는 null 값이 되며 해당 경고가 나타납니다.</p>

<p>리액트 공식 문서에서도 해당 부분을 해결하기 위해서는
e.persist 라는 함수를 사용하라고 되어있고 사용은 간단하다.</p>

<p>해당 onChange or onClick 에러 코드에서 e.persist()를 호출하면 된다.</p>

<p>onChange={
(e)=&gt;{
e.persist();
console.log(e.type);
console.log(e.target.value);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          setTimeout(()=&gt;{
            console.warn(e.type);
          })
        }
      }&gt;
</code></pre></div></div>

<p>호출시에는 이제 setTimeout에서도 e.type이 노출됩니다.</p>

<p>동작이 왜 이렇게 바뀌냐면!</p>

<p>기본적으로 리액트에서 사용되고있는 SyntheticEvent 는 객체 풀링 방식을 사용합니다. (Object Pooling) 매 이벤트마다 해당 객체 사용되는것에 대해서 성능상의 이유로
리액트에서는 Object Pooling을 사용함으로써 객체 생성 시간을 줄이고
GC에 대한 노출도 줄이며 메모리관리에 소비되는 시간을 줄이는 방식을 사용하고 있기 때문입니다.
그렇기 때문에 객체가 호출되고 난 후에 이벤트 속성이 초기화 됩니다.</p>

<p>그래서 비동기로 호출하였을 경우에는 해당 객체가 비어있는 현상이 발생합니다.
해결책으로 e.persist를 호출하게되면 기존에 사용하고 있던 이벤트 풀 ( Event Pool ) 에서 제거되고 사용자 코드로 사용이 된다.</p>]]></content><author><name>이승호</name></author><category term="REACT" /><category term="e.persist" /><category term="리액트 Value 에러" /><summary type="html"><![CDATA[다시 만난 리액트]]></summary></entry><entry><title type="html">HTTP 헤더의 크기제한이란?</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="HTTP 헤더의 크기제한이란?" /><published>2022-07-22T00:00:00+09:00</published><updated>2022-07-22T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<h3 id="http-통신을-사용하다-보면-헤더에-정보를-담아-보내는-일이-빈번하다">HTTP 통신을 사용하다 보면 헤더에 정보를 담아 보내는 일이 빈번하다.</h3>

<p>HTTP 헤더에는 크기제한이 있는가에 대한 의문이 들었다.<br />
서치 결과 답은 상황에 따라 다르다는 것이다.</p>

<p>기본적으로 HTTP RFC에는 헤더의 최대 크기 제한은 없지만<br />
우리가 사용하는 웹서버 소프트웨어에서 크기를 제한하고 있다.</p>

<p>Here is the limit of most popular web server</p>

<h3 id="web-server-defualt-limit">Web Server Defualt Limit</h3>

<ul>
  <li>Apache 8K</li>
  <li>Nginx 4K-8K</li>
  <li>IIS 8K-16K</li>
  <li>Tomcat 8K – 48K</li>
  <li>Node (&lt;13) - 8K; (&gt;13) - 16K</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">No, HTTP does not define any limit. However most web servers do limit size of headers they accept. For example in Apache default limit is 8KB, in IIS it's 16K. Server will return 413 Entity Too Large error if headers size exceeds that limit.</code></p>

<p>HTTP에는 제한을 두기 않지만 대부분의 웹서버는 제한을 두고 있다.</p>

<p>위의 명시된 사이즈를 넘을경우 <code class="language-plaintext highlighter-rouge">You will return 413 code</code></p>

<p>물론 위의 제한에 맞춰서 해야한다기 보다는 설정값을 변경하면 사이즈를 조절할 수 있다.</p>

<h3 id="설정-바꾸는-법">설정 바꾸는 법</h3>

<p>톰캣의 경우 maxHttpHeaderSize 어트리뷰트값을 지정해주면 해당 제한을 바꿀수 있다.</p>

<h3 id="결론">결론</h3>

<p>HTTP 자체적으로는 크기제한이 없다.
But, Web Server 소프트웨어 입장에선 제한하지 않을 경우의 리스크를 감수하기보단<br />
제한을 둔 후에 사용자가 그 제한을 컨트롤할 수 있게끔 만든 것으로 보인.</p>

<p>출처 : https://stackoverflow.com/questions/686217/maximum-on-http-header-values
출처 : https://tomcat.apache.org/tomcat-8.0-doc/config/http.html</p>]]></content><author><name>이승호</name></author><category term="HTTP" /><category term="HTTP 헤더" /></entry><entry><title type="html">[Mac] webStorm 단축키 정리</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="[Mac] webStorm 단축키 정리" /><published>2022-07-20T00:00:00+09:00</published><updated>2022-07-20T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<h3 id="control--return">control + return</h3>

<ul>
  <li>(Navigator에서) 새 파일 생성하기 option(alt) + F12 터미널창 열기</li>
</ul>

<h3 id="command-">command <code class="language-plaintext highlighter-rouge">+</code></h3>

<ul>
  <li>preference 열기</li>
</ul>

<h3 id="command--delete">command + delete</h3>

<ul>
  <li>한 줄 라인 없애기 /</li>
</ul>

<h3 id="command--return">command + return</h3>

<ul>
  <li>현재줄에서 커서 유지하면서 다음줄 새로 생성하기</li>
</ul>

<h3 id="shiftcommand-return">shift(command) + return </h3>

<ul>
  <li>아래로 새로운 라인으로 줄바꿈하기</li>
</ul>

<h3 id="command--optionalt-return">command + option(alt) +  return </h3>

<ul>
  <li>윗줄로 새로운 라인으로 줄바꿈하기</li>
</ul>

<h3 id="control--shift--j">control + shift + J</h3>

<ul>
  <li>라인 합치기</li>
</ul>

<h3 id="command--d">command + d </h3>

<ul>
  <li>한 줄 복사하기</li>
</ul>

<h3 id="command--shift--u">command + shift + U </h3>

<ul>
  <li>대소문자 토글하기</li>
</ul>

<h3 id="optionalt--방향키상하">option(alt) + 방향키(상하) </h3>

<ul>
  <li>selection 지정하기( 방향키 위: expand, 방향키 아래: shrink )</li>
</ul>

<h3 id="command--option--t">command + option + T  </h3>

<ul>
  <li>emmet의 코드 wrap abbreviation</li>
</ul>

<h3 id="control--optionalt">control + option(alt) </h3>

<ul>
  <li>+ 방향키(좌우) emmet의 moving next or previous edit point</li>
</ul>

<h3 id="shift--f6">shift + F6 </h3>

<ul>
  <li>file rename</li>
</ul>

<h3 id="command--shift--deletefn">command + shift + delete(fn) </h3>

<ul>
  <li>코드 선택적 remove</li>
</ul>

<h3 id="shift--optionalt--방향키상하">shift + option(alt)  + 방향키(상하)  </h3>

<ul>
  <li>코드 라인 상하로 옮기기</li>
</ul>

<h3 id="shift--command--방향키상하">shift + command  + 방향키(상하)  </h3>

<ul>
  <li>코드 라인 소스포맷팅하면서 상하로 옮기기</li>
</ul>

<h3 id="command--l">command + L  </h3>

<ul>
  <li>Go to the Line</li>
</ul>

<h3 id="command--shift--8">command + shift + 8 </h3>

<ul>
  <li>column selection mode</li>
</ul>

<h3 id="optalt--드래그">opt(alt) + 드래그 </h3>

<ul>
  <li>column selection mode</li>
</ul>

<h3 id="command--드래그">command + 드래그 </h3>

<ul>
  <li>드래그 한 코드 마우스로 원하는 위치로 이동시키기</li>
</ul>

<h3 id="command--">command + /  </h3>

<ul>
  <li>라인 한줄씩 주석처리하기</li>
</ul>

<h3 id="command--optalt--">command + opt(alt) + /  </h3>

<ul>
  <li>드래그 섹션이나 해당 커서섹션만 주석처리하기</li>
</ul>

<h3 id="optalt--">opt(alt) + /  </h3>

<ul>
  <li>Remember previous word</li>
</ul>

<h3 id="optalt--shift--">opt(alt) + shift + / </h3>

<ul>
  <li>Remember next word</li>
</ul>

<h3 id="shift--control--j">shift + control + J  </h3>

<ul>
  <li>라인 합치기</li>
</ul>

<h3 id="command--shift--v">command + shift + v  </h3>

<ul>
  <li>최근 복사했던 목록 보여주기</li>
</ul>

<h3 id="command--shift--">command + shift + [,]  </h3>

<ul>
  <li>열린 파일 간 이동</li>
</ul>

<h3 id="control--k">control + k  </h3>

<ul>
  <li>커서 라인 뒤의 코드만 모두 지움</li>
</ul>

<h3 id="control--g">control + g </h3>

<ul>
  <li>드래그한 블럭과 일치 코드 블럭만 선택하기</li>
</ul>

<h3 id="command--control--g">command + control + g </h3>

<ul>
  <li>드래그한 블럭과 일치하는 코드 모두 선택하기</li>
</ul>

<h3 id="command--shift--o">command + shift + O </h3>

<ul>
  <li>project내의 파일 바로 찾기</li>
</ul>

<h3 id="command--optalt--o">command + opt(alt) + O   </h3>

<ul>
  <li>symbol 찾기 ( 코드명, 기호등등 )</li>
</ul>

<h3 id="control--tab">control + tab  </h3>

<ul>
  <li>switcher</li>
</ul>

<h3 id="command--e">command + E  </h3>

<ul>
  <li>최근 열었던 파일 항목 보여주기</li>
</ul>

<h3 id="command--shift--u----">command + shift + U         </h3>

<ul>
  <li>영문 텍스트 대문자를 소문자로 소문자를 대문자로 변환하기</li>
</ul>

<h3 id="command---마침표----">command + . (마침표)         </h3>

<ul>
  <li>코드 폴딩 기능 사용하기</li>
</ul>

<h3 id="command--opt--l----">command + opt + L         </h3>

<ul>
  <li>소스 포맷하기</li>
</ul>

<h3 id="control--shift--j----">control + shift + J         </h3>

<ul>
  <li>소스 드래그 영역 싱글라인으로 만들기</li>
</ul>

<h3 id="command--shift--del----">command + shift + del         </h3>

<ul>
  <li>소스 태그 선택적 삭제하기</li>
</ul>

<h3 id="command--opt--좌우-방향키----">command + opt + 좌,우 방향키          </h3>

<ul>
  <li>Edit Point 이동하기</li>
</ul>

<h3 id="control--opt--n----">control + opt + N         </h3>

<ul>
  <li>파일 생성하기</li>
</ul>

<h3 id="control--opt--shift--상하-방향키----">control + opt + shift + 상,하 방향키         </h3>

<ul>
  <li>소스 수정,편집 내용으로 이동하기</li>
</ul>]]></content><author><name>이승호</name></author><category term="webstorm" /><category term="webstorm 단축키" /><summary type="html"><![CDATA[까먹었을 때 다시 보는 용도]]></summary></entry><entry><title type="html">프로젝트에 eslint-airbnb 적용해 나만의 eslint 규칙 만들기</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="프로젝트에 eslint-airbnb 적용해 나만의 eslint 규칙 만들기" /><published>2022-07-15T00:00:00+09:00</published><updated>2022-07-15T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm i --save-dev eslint-config-airbnb-base eslint-plugin-import
npm i --save-dev eslint-config-prettier
</code></pre></div></div>

<p>우선 npm i를 이용해 위와 같이 eslint-airbnb와 config-prettier를 설치해줍니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = {
  env: {
    commonjs: true,
    es2021: true,
    node: true,
  },
  extends: ["airbnb-base", "prettier"],
  parserOptions: {
    ecmaVersion: 12,
  },
  rules: {
    "new-cap": 0,
    "max-len": 0,
    "valid-jsdoc": 0,
    "require-jsdoc": 1,
    "no-unused-vars": 1,
    "no-trailing-spaces": 0,
    "no-undef": 0,
    "spaced-comment": 0,
    "prefer-const": 0,
  },
};
</code></pre></div></div>

<p>그 다음 .eslintrc.js 파일을 최상단에 위치시켜 생성해주고,</p>

<p>위 파일과 같이 입력해줍니다.</p>

<p>그 후 나타나는 오류들은 fix ~~ 로 입맛에 맞게 수정해주면 eslint-airbnb를 적용해 나만의 eslint 규칙을 만들어 프로젝트를 일관되게 유지할 수 있습니다!</p>

<p>만약 팀원들과 함께 하는 프로젝트라면 규칙을 자동 적용함으로써 조금 더 일관된 코드 스타일을 유지하며 프로젝트를 진행할 수 있을 것입니다 :)</p>]]></content><author><name>이승호</name></author><category term="eslint" /><category term="eslint-airbnb" /></entry><entry><title type="html">moment.js를 이용해 날짜 계산하는 방법</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="moment.js를 이용해 날짜 계산하는 방법" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Node.js] moment.js로 날짜(date)관련 작업을 쉽게하기
</code></pre></div></div>

<p><a href="https://hanswsw.tistory.com/5">https://hanswsw.tistory.com/5</a></p>

<p>[[Node.js] moment.js로 날짜(date)관련 작업을 쉽게하기</p>

<p>JS에서 날짜 관련 작업을 할 때, 아마 가장 유명하고 유용하게 사용되어지는 라이브러리는 moment.js가 아닐까 싶습니다. JS에 기본적으로 내장되어있는 Date개체를 불러와서, 날짜 관련 작업을 해</p>

<p>hanswsw.tistory.com](https://hanswsw.tistory.com/5)</p>

<h3 id="moment-날짜계산">[moment] 날짜계산</h3>

<p><a href="https://romeoh.tistory.com/324">https://romeoh.tistory.com/324</a></p>]]></content><author><name>이승호</name></author><category term="moment js" /><category term="날짜계산" /></entry><entry><title type="html">ecosystem config js 용어 정리</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="ecosystem config js 용어 정리" /><published>2022-07-06T00:00:00+09:00</published><updated>2022-07-06T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = {
    apps: [
        {
            name: 'nodejs-sequelize-pm2', // pm2 name
            script: './server.js', // // 앱 실행 스크립트
            instances: 3, // 클러스터 모드 사용 시 생성할 인스턴스 수
            exec_mode: 'cluster', // fork, cluster 모드 중 선택
            (   exec_mode: "cluster", //CPU 사용을 위한 클러스터 모드 )
            merge_logs: true, // 클러스터 모드 사용 시 각 클러스터에서 생성되는 로그를 한 파일로 합쳐준다.
            autorestart: true, // 프로세스 실패 시 자동으로 재시작할지 선택
            watch: false, // 파일이 변경되었을 때 재시작 할지 선택
            // max_memory_restart: "512M", // 프로그램의 메모리 크기가 일정 크기 이상이 되면 재시작한다.
            env: {
                // 개발 환경설정
                NODE_ENV: 'development',
            },
            env_production: {
                // 운영 환경설정 (--env production 옵션으로 지정할 수 있다.)
                NODE_ENV: 'production',
            }
        },
    ]
};
</code></pre></div></div>

<p>https://velog.io/@altmshfkgudtjr/PM2-Node.js-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4</p>]]></content><author><name>이승호</name></author><category term="ecosystem" /><category term="config" /></entry><entry><title type="html">npm run dev 에러 (feat. Node js)</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="npm run dev 에러 (feat. Node js)" /><published>2022-06-26T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p>npm run dev 에러를 만났다.
<img width="853" alt="스크린샷 2022-06-26 22 46 40" src="https://user-images.githubusercontent.com/92617810/175818748-77b09a4f-9538-474b-9acf-8a6b4811b472.png" />
<img width="877" alt="스크린샷 2022-06-26 22 46 59" src="https://user-images.githubusercontent.com/92617810/175818759-00759346-4833-44e6-a7f8-83f0af159170.png" /></p>

<p>기본 모듈 시스템이 CommonJS인 Node.js에서<br />
바벨을 통해 ESModule(+ 최신 ES문법)을 사용할 수 있도록 하고 있다.</p>

<p>package.json의 type:module을 추가 하는 건<br />
프로젝트의 모듈 시스템만ESModule로 변경하는 것으로,<br />
바벨은 적용되지 않았을 수 있습니다.</p>

<p>package.json 최상단에 “type”: “module”을 추가해서 해결했다!</p>]]></content><author><name>이승호</name></author><category term="Node js" /><category term="Javascript" /><summary type="html"><![CDATA[SyntaxError: Cannot use import statement outside a module]]></summary></entry><entry><title type="html">젠킨스란 무엇일까? (feat. CI/CD)</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="젠킨스란 무엇일까? (feat. CI/CD)" /><published>2022-06-23T00:00:00+09:00</published><updated>2022-06-23T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p>젠킨스는 소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴입니다. CI(Continuous Integration) 툴 이라고 표현합니다. 젠킨스에 대해 알아보기 전에 우선 CI/CD에 대해 먼저 알아보자.</p>

<p>CI/CD란?</p>

<p>CI
CI는 Continuous Integration 즉, 지속적인 통합이라는 의미다.</p>

<p>지속적인 통합이란,</p>

<p>어플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합히는 것을 의미합니다. (가능하다면 하루에 여러번까지)</p>

<p>이러한 CI의 핵심 목표는 버그를 신속하게 찾아 해결하고, 소프트웨어의 품질을 개선하고, 새로운 업데이트의 검증 및 릴리즈의 시간을 단축시키는 것에 있습니다.</p>

<p>CD
CD란? 해석하자면, 지속적인 서비스 제공 혹은 지속적인 배포 라는 의미죠.</p>

<p>Continuous Delivery는 공유 레포지토리로 자동으로 Release 하는 것, Continuous Deployment는 Production 레벨까지 자동으로 deploy 하는 것을 의미합니다.</p>

<p>정리하자면, CI가 새로운 소스코드의 빌드, 테스트, 병합까지를 의미하였는데, CD는 개발자의 변경 사항이 레포지토리를 넘어, 고객의 프로덕션(Production) 환경까지 릴리즈 되는 것을 의미합니다.</p>

<p>CI에서 예로 든 MSA와 같은 환경에서 Agile 방법론이 적용될 경우, 서비스의 사용자는 최대한 빠른 시간 내에 최신 버전의 Production을 제공받을 필요가 있습니다.</p>

<p>이 때, 소프트웨어가 언제든지 신뢰 가능한 수준의 버전을 유지할 수 있도록 support 하는 것이 CD라고 할 수 있죠.</p>

<p>이는 서비스의 개발팀과 비즈니스팀(영업, CS팀 등) 간의 커뮤니케이션 부족 문제를 해결해 줌으로써, 배포에 이르기까지의 노력을 최소한으로 단축시켜 준다는 Benefit을 제공합니다.</p>

<p>이러한 CI/CD를 가능케 해주는 것이 바로 젠킨스입니다.</p>

<p>젠킨스란?</p>

<p>젠킨스와 같은 CI툴이 등장하기 전에는 일정시간마다 빌드를 실행하는 방식이 일반적이었습니다. 특히 개발자들이 당일 작성한 소스들의 커밋이 모두 끝난 심야 시간대에 이러한 빌드가 타이머에 의해 집중적으로 진행되었는데, 이를 Nightly-Build라고 했습니다. 하지만, 젠킨스는 정기적인 빌드에서 한발 나아가 SVN, Git과 같은 버전관리시스템과 연동하여 소스의 커밋을 감지하면 자동적으로 자동화 테스트가 포함된 빌드가 작동되도록 설정할 수 있습니다.</p>

<p>젠킨스가 주는 이점
개발중인 프로젝트에서 커밋은 매우 빈번히 일어나기 때문에 커밋 횟수만큼 빌드를 실행하는 것이 아니라 작업이 큐잉되어 자신이 실행될 차례를 기다리게 됩니다.</p>

<p>코드의 변경과 함께 이뤄지는 이 같은 자동화된 빌드와 테스트 작업들은 다음과 같은 이점들을 가져다 줍니다.</p>

<p>프로젝트 표준 컴파일 환경에서의 컴파일 오류 검출
자동화 테스트 수행
정적 코드 분석에 의한 코딩 규약 준수여부 체크
프로파일링 툴을 이용한 소스 변경에 따른 성능 변화 감시
결합 테스트 환경에 대한 배포작업
이 외에도 젠킨스는 500여가지가 넘는 플러그인을 온라인으로 간단히 인스톨 할 수 있는 기능을 제공하고 있으며 파이썬과 같은 스크립트를 이용해 손쉽게 자신에게 필요한 기능을 추가 할 수 있습니다.</p>

<p>각종 배치 작업의 간략화
프로젝트 기간 중에 개발자들은 순수한 개발 작업 이외에 DB셋업이나 환경설정, Deploy작업과 같은 단순 작업에 시간과 노력을 들이는 경우가 빈번합니다. 데이터베이스의 구축, 어플리케이션 서버로의 Deploy, 라이브러리 릴리즈와 같이 이전에 CLI로 실행되던 작업들이 젠킨스 덕분에 웹 인터페이스로 손쉽게 가능해졌습니다.</p>

<p>Build 자동화의 확립
빌드 툴의 경우 Java는 maven과 gradle이 자리잡고 있으며, 이미 빌드 관리 툴을 이용해 프로젝트를 진행하고 있다면 젠킨스를 사용하지 않을 이유가 없습니다. 젠킨스와 연동하여 빌드 자동화를 통해 프로젝트 진행의 효율성을 높일 수 있습니다.</p>

<p>자동화 테스트
자동화 테스트는 젠킨스를 사용해야 하는 가장 큰 이유 중 하나이며, 사실상 자동화 테스트가 포함되지 않은 빌드는 CI자체가 불가능하다고 봐도 무방합니다. 젠킨스는 Subversion이나 Git과 같은 버전관리시스템과 연동하여 코드 변경을 감지하고 자동화 테스트를 수행하기 때문에 만약 개인이 미처 실시하지 못한 테스트가 있다 하여도 든든한 안전망이 되어줍니다. 제대로 테스트를 거치지 않은 코드를 커밋하게 되면 화난 젠킨스를 만나게 됩니다.</p>

<p>코드 표준 준수여부 검사
자동화 테스트와 마찬가지로 개인이 미처 실시하지 못한 코드 표준 준수 여부의 검사나 정적 분석을 통한 코드 품질 검사를 빌드 내부에서 수행함으로써 기술적 부채의 감소에도 크게 기여합니다.</p>

<p>빌드 파이프라인 구성
2개 이상의 모듈로 구성되는 레이어드 아키텍처가 적용 된 프로젝트에는 그에 따는 빌드 파이프라인 구성이 필요합니다. 예를 들면, 도메인 -&gt; 서비스 -&gt; UI와 같이 각 레이어의 참조 관계에 따라 순차적으로 빌드를 진행하지 않으면 안됩니다. 젠킨스에서는 이러한 빌드 파이프라인의 구성을 간단히 할 수 있으며, 스크립트를 통해서 매우 복잡한 제어까지도 가능합니다.</p>]]></content><author><name>이승호</name></author><category term="CI/CD" /><category term="Jenkins" /><category term="Pipeline" /><category term="배포자동화" /><summary type="html"><![CDATA[Jenkins]]></summary></entry><entry><title type="html">NoSQL이란?</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="NoSQL이란?" /><published>2022-06-22T00:00:00+09:00</published><updated>2022-06-22T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p>NoSQL :</p>

<p>NoSQL은 (non SQL 또는 non relational) 기존 RDBMs 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하며, 관계형 데이터 베이스의 한계를 극복하기 위한 데이터 저장소의 새로운 형태로, 수평적 확장성을 갖고 있다.</p>

<p>RDBMS가 클라이언트/서버 환경에 맞는 데이터 저장기술이라면, NoSQL은 클라우드 환경에 맞는 저장 기술이다.</p>

<p>NoSQL의 특징<br />
NoSQL은 RDBMS와는 달리 데이터 간의 관계를 정의하지 않는다.
가장 큰 특징 중 하나는 관계형 데이터 베이스인 RDBMS가 데이터의 관계를 Foreign Key 등으로 정의하고 이를 이용해 Join 등의 관계형 연산을 한다고 하면, NoSQL은 데이터 간의 관계를 정의하지 않는다. 데이터 테이블은 그냥 하나의 테이블이며 각 테이블 간의 관계를 정의하지 않고 일반적으로 테이블 간의 Join도 불가능하다.
RDBMS에 비해 훨씬 더 대용량의 데이터를 저장할 수 있다.
RDBMS의 복잡도와 용량의 한계를 극복하기 위한 목적으로 등장한 만큼 페타바이트급의 대용량 데이터를 저장할 수 있다.
분산형 구조이다.
NoSQL은 기존 RDBMS와는 다르게 하나의 고성능 머신에 데이터를 저장하는 것이 아니라 일반적인 서버 수십 대를 연결해 데이터를 저장 및 처리하는 구조를 갖는다. 즉 분산형 구조를 통해 데이터를 여러 대의 서버에 분산해 저장하고 분산 시에 데이터를 상호 복제해 특정 서버에 장애가 발생했을 때에도 데이터 유실이나 서비스 중지가 없는 구조의 형태를 가진다.
고정되지 않은 테이블 스키마를 갖는다.
RDBMS와는 다르게 테이블의 스키마가 유동적이다. 데이터를 저장하는 컬럼은 각기 다른 이름과 다른 데이터 타입을 갖는 것이 허용된다.
스키마란? 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.
RDBMS 와 NoSQL의 차이
RDBMS
장점</p>

<ul>
  <li>DATA를 Column과 Row 형태로 저장</li>
  <li>데이터의 분류, 정렬, 탐색 속도가 비교적 빠름</li>
  <li>SQL 이라는 구조화 된 질의를 통해 데이터를 다룰 수 있음</li>
  <li>작업의 완전성을 보장
단점</li>
  <li>데이터의 UPDATE가 빠르다</li>
  <li>반드시 스키마 규격에 맞춰서 데이터를 다뤄야 한다.</li>
  <li>
    <p>데이터 처리에 대한 부하 발생시, 처리가 어렵다.
NoSQL
장점</p>
  </li>
  <li>데이터간의 관계를 정의 하지 않는다(테이블 간의 관계(JOIN) 불필요)</li>
  <li>RDBMS 보다 복합도가 떨어져, 훨씬 대용량의 데이터를 저장, 관리 할 수 있다.</li>
  <li>테이블에 스키마가 정해져있지 않아 데이터 저장이 비교적 자유롭다.</li>
  <li>
    <p>수평적 확장이 어려운 RDBMS보다는 수평적 확장이 쉽다.
단점</p>
  </li>
  <li>스키마가 정해져 있지 않아, 데이터에 대한 규격화가 되어있지 않음.</li>
  <li>DATA를 UPDATE하는데 비교적 느림</li>
  <li>중복된 데이터가 저장될 수 있다.</li>
</ul>

<p>NoSQL에 대한 오해
NoSQL이 등장하면서 기존의 RDBMS의 단점들이 부각되기는 하지만 여전히 RDMB의 성능과 기능은 뛰어나다.</p>

<p>설정과 튜닝을 통해서 NoSQL에 비해 원하는 성능과 확장성을 충분히 갖추고 있다.</p>

<p>NoSQL을 검토할때는 3가지 측면을 고려한다.</p>

<p>데이터의 규모와 데이터의 처리속도 그리고 데이터의 형태이다.</p>

<p>많은 데이터와 빠른 속도로 데이터를 처리하는 것을 다 만족하는 데이터베이스는 없습니다.</p>

<p>인메모리 기반의 데이터베이스는 당연히 속도가 빠르겠지만 확장성에 있어서 한계가 있기 때문에 수십테라바이트, 수백테라바이트의 빅데이터를 다루기에는 적합하지 않습니다.</p>

<p>반면, 빅데이터를 처리하는 경우에는 상대적으로 읽기/쓰기/업데이트등의 성능 및 기능의 제약이 존재합니다.</p>

<p>데이터의 복잡도에 따라서 성능의 차이가 발생하게 됩니다. 단순한 작은 크기의 값을 다루는 key/value 인 경우에는 그 성능이 매우 뛰어난 데이터베이스더라도 처리하는</p>

<p>value의 데이터 크기가 좀 커지고 복잡해지면 성능이 떨어지는 경우도 있지만 NoSQL의 경우에는 좀 더 복잡한 데이터 구조를 수용하면서도 성능을 어느정도 보장해주는것이 있다.</p>

<p>NoSQL들을 보면 메모리를 많이 사용해서 성능도 향상시키면서 확장성도 어느 정도갖추도록 아키텍쳐들이 개선되어 가고 있지만 이를 위해서 필요한 서버의 성능도 올라가야합니다.</p>

<p>이를 위해 서버의 비용도 부담이 되기 때문에 이점도 고려를 해야하는 사항입니다.</p>]]></content><author><name>이승호</name></author><category term="몽고DB" /><category term="NoSQL" /><category term="Blog" /><summary type="html"><![CDATA[몽고DB야 안녕!]]></summary></entry><entry><title type="html">백엔드 개발자 첫 출근 후기 (feat. Node js)</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="백엔드 개발자 첫 출근 후기 (feat. Node js)" /><published>2022-06-21T00:00:00+09:00</published><updated>2022-06-21T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">아마 생활코딩님이 없었다면 지금의 나도 없지 않을까?</code><br />
코딩이라는 것에 관심이 있었지만<br />
만약 생활코딩님의 입문자들을 위한 영상이 없었더라면,,
입문하기 어렵다는 이유로 개발을 시작하지 않았을지도 모른다.</p>

<p>그렇게 개발 공부를 하면서<br />
사실 직장을 가지게 될 것이라고는 생각하지 않았었다.</p>

<p>그저 재미로 시작한 것일 뿐인데<br />
하다보니 내 생활이 되고 점점 개발은 내게 스며들어왔다.</p>

<p>서론이 너무 길었다!</p>

<p>백엔드 개발자로 이틀을 출근했다.<br />
출근 전 머릿속으로 어떤 모습일지 어떻게 일하게 될 지<br />
상상하고 즐겁게 출근했는데 ㅎㅎ</p>

<p>첫 날은 가자마자 같이 일하게 될 동료분들과 인사를 나누고<br />
포맷된 아이맥 앞에 앉았다.<br />
맥북은 계속 써봤지만 아이맥을 막상 보니 커다란 맥북을 보는 기분이었다.</p>

<p>포맷된 아이맥으로 개발 환경 세팅을 했다.<br />
vscode부터 시작해서 mongodb, postman, webstorm까지<br />
그리고 협업을 위한 슬랙, 깃헙, 지라, 회사 개인 계정을 지급받았다.</p>

<p>아직 회사 내 개발이 어떻게 돌아가는지 잘 모르기 때문에 사실 도메인 이해가 먼저고,<br />
이제 막 도메인이 어떻게 돌아가는지 파악하고있다~~</p>

<p>그래도 node js로 이루어진 백엔드 파트여서 다행이다 싶다가도<br />
몽고DB로 이루어진 DB파트를 보며 알아갈게 생겨서 재밌겠다!라는 생각도 들었다ㅎㅎ</p>

<p>고작 이틀 지났지만 대표님과 회사 동료분들의 인상이 다들 참 좋으시다.<br />
나이대도 나와 비슷해서 친근한 느낌마저 든다 :)</p>

<p>이틀 동안 나가보니 딱 간략하게 정리하자면!!</p>

<p>회사 내 도메인 파악을 끝내고 어서 실무에 투입되서 몰입해보고 싶다!<br />
그리고 역시 공부할 때와 실제로 적용되서 비즈니스로 운영되는 코드를 보는 것은<br />
느낌 자체가 다르다.</p>

<p>실질적으로 사용성이 좋은 코드, 성능에 맞는 코드가 필요하기 때문에<br />
이제 제대로 경기장에 나온 느낌이다 ㅎㅎ</p>

<p>개발 공부를 처음 시작할 때 즈음 블로그에 기록했었던 말이 생각난다.<br />
빠르게 가는 것보다 천천히 한 걸음씩 가자!</p>]]></content><author><name>이승호</name></author><category term="개발자 블로그" /><category term="backend" /><category term="첫 출근" /><category term="Blog" /><summary type="html"><![CDATA[달콤한 9개월 간의 여정]]></summary></entry></feed>