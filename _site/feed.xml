<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-06T23:26:14+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">leo-labbb DEVLOG</title><subtitle>awesome world</subtitle><author><name>이승호</name></author><entry><title type="html">ecosystem config js 용어 정리</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="ecosystem config js 용어 정리" /><published>2022-07-06T00:00:00+09:00</published><updated>2022-07-06T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = {
    apps: [
        {
            name: 'nodejs-sequelize-pm2', // pm2 name
            script: './server.js', // // 앱 실행 스크립트
            instances: 3, // 클러스터 모드 사용 시 생성할 인스턴스 수
            exec_mode: 'cluster', // fork, cluster 모드 중 선택
            (   exec_mode: "cluster", //CPU 사용을 위한 클러스터 모드 )
            merge_logs: true, // 클러스터 모드 사용 시 각 클러스터에서 생성되는 로그를 한 파일로 합쳐준다.
            autorestart: true, // 프로세스 실패 시 자동으로 재시작할지 선택
            watch: false, // 파일이 변경되었을 때 재시작 할지 선택
            // max_memory_restart: "512M", // 프로그램의 메모리 크기가 일정 크기 이상이 되면 재시작한다.
            env: {
                // 개발 환경설정
                NODE_ENV: 'development',
            },
            env_production: {
                // 운영 환경설정 (--env production 옵션으로 지정할 수 있다.)
                NODE_ENV: 'production',
            }
        },
    ]
};
</code></pre></div></div>

<p>https://velog.io/@altmshfkgudtjr/PM2-Node.js-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EC%84%9C%EB%B9%84%EC%8A%A4</p>]]></content><author><name>이승호</name></author><category term="ecosystem" /><category term="config" /></entry><entry><title type="html">npm run dev 에러 (feat. Node js)</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="npm run dev 에러 (feat. Node js)" /><published>2022-06-26T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p>npm run dev 에러를 만났다.
<img width="853" alt="스크린샷 2022-06-26 22 46 40" src="https://user-images.githubusercontent.com/92617810/175818748-77b09a4f-9538-474b-9acf-8a6b4811b472.png" />
<img width="877" alt="스크린샷 2022-06-26 22 46 59" src="https://user-images.githubusercontent.com/92617810/175818759-00759346-4833-44e6-a7f8-83f0af159170.png" /></p>

<p>기본 모듈 시스템이 CommonJS인 Node.js에서<br />
바벨을 통해 ESModule(+ 최신 ES문법)을 사용할 수 있도록 하고 있다.</p>

<p>package.json의 type:module을 추가 하는 건<br />
프로젝트의 모듈 시스템만ESModule로 변경하는 것으로,<br />
바벨은 적용되지 않았을 수 있습니다.</p>

<p>package.json 최상단에 “type”: “module”을 추가해서 해결했다!</p>]]></content><author><name>이승호</name></author><category term="Node js" /><category term="Javascript" /><summary type="html"><![CDATA[SyntaxError: Cannot use import statement outside a module]]></summary></entry><entry><title type="html">젠킨스란 무엇일까? (feat. CI/CD)</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="젠킨스란 무엇일까? (feat. CI/CD)" /><published>2022-06-23T00:00:00+09:00</published><updated>2022-06-23T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p>젠킨스는 소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴입니다. CI(Continuous Integration) 툴 이라고 표현합니다. 젠킨스에 대해 알아보기 전에 우선 CI/CD에 대해 먼저 알아보자.</p>

<p>CI/CD란?</p>

<p>CI
CI는 Continuous Integration 즉, 지속적인 통합이라는 의미다.</p>

<p>지속적인 통합이란,</p>

<p>어플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합히는 것을 의미합니다. (가능하다면 하루에 여러번까지)</p>

<p>이러한 CI의 핵심 목표는 버그를 신속하게 찾아 해결하고, 소프트웨어의 품질을 개선하고, 새로운 업데이트의 검증 및 릴리즈의 시간을 단축시키는 것에 있습니다.</p>

<p>CD
CD란? 해석하자면, 지속적인 서비스 제공 혹은 지속적인 배포 라는 의미죠.</p>

<p>Continuous Delivery는 공유 레포지토리로 자동으로 Release 하는 것, Continuous Deployment는 Production 레벨까지 자동으로 deploy 하는 것을 의미합니다.</p>

<p>정리하자면, CI가 새로운 소스코드의 빌드, 테스트, 병합까지를 의미하였는데, CD는 개발자의 변경 사항이 레포지토리를 넘어, 고객의 프로덕션(Production) 환경까지 릴리즈 되는 것을 의미합니다.</p>

<p>CI에서 예로 든 MSA와 같은 환경에서 Agile 방법론이 적용될 경우, 서비스의 사용자는 최대한 빠른 시간 내에 최신 버전의 Production을 제공받을 필요가 있습니다.</p>

<p>이 때, 소프트웨어가 언제든지 신뢰 가능한 수준의 버전을 유지할 수 있도록 support 하는 것이 CD라고 할 수 있죠.</p>

<p>이는 서비스의 개발팀과 비즈니스팀(영업, CS팀 등) 간의 커뮤니케이션 부족 문제를 해결해 줌으로써, 배포에 이르기까지의 노력을 최소한으로 단축시켜 준다는 Benefit을 제공합니다.</p>

<p>이러한 CI/CD를 가능케 해주는 것이 바로 젠킨스입니다.</p>

<p>젠킨스란?</p>

<p>젠킨스와 같은 CI툴이 등장하기 전에는 일정시간마다 빌드를 실행하는 방식이 일반적이었습니다. 특히 개발자들이 당일 작성한 소스들의 커밋이 모두 끝난 심야 시간대에 이러한 빌드가 타이머에 의해 집중적으로 진행되었는데, 이를 Nightly-Build라고 했습니다. 하지만, 젠킨스는 정기적인 빌드에서 한발 나아가 SVN, Git과 같은 버전관리시스템과 연동하여 소스의 커밋을 감지하면 자동적으로 자동화 테스트가 포함된 빌드가 작동되도록 설정할 수 있습니다.</p>

<p>젠킨스가 주는 이점
개발중인 프로젝트에서 커밋은 매우 빈번히 일어나기 때문에 커밋 횟수만큼 빌드를 실행하는 것이 아니라 작업이 큐잉되어 자신이 실행될 차례를 기다리게 됩니다.</p>

<p>코드의 변경과 함께 이뤄지는 이 같은 자동화된 빌드와 테스트 작업들은 다음과 같은 이점들을 가져다 줍니다.</p>

<p>프로젝트 표준 컴파일 환경에서의 컴파일 오류 검출
자동화 테스트 수행
정적 코드 분석에 의한 코딩 규약 준수여부 체크
프로파일링 툴을 이용한 소스 변경에 따른 성능 변화 감시
결합 테스트 환경에 대한 배포작업
이 외에도 젠킨스는 500여가지가 넘는 플러그인을 온라인으로 간단히 인스톨 할 수 있는 기능을 제공하고 있으며 파이썬과 같은 스크립트를 이용해 손쉽게 자신에게 필요한 기능을 추가 할 수 있습니다.</p>

<p>각종 배치 작업의 간략화
프로젝트 기간 중에 개발자들은 순수한 개발 작업 이외에 DB셋업이나 환경설정, Deploy작업과 같은 단순 작업에 시간과 노력을 들이는 경우가 빈번합니다. 데이터베이스의 구축, 어플리케이션 서버로의 Deploy, 라이브러리 릴리즈와 같이 이전에 CLI로 실행되던 작업들이 젠킨스 덕분에 웹 인터페이스로 손쉽게 가능해졌습니다.</p>

<p>Build 자동화의 확립
빌드 툴의 경우 Java는 maven과 gradle이 자리잡고 있으며, 이미 빌드 관리 툴을 이용해 프로젝트를 진행하고 있다면 젠킨스를 사용하지 않을 이유가 없습니다. 젠킨스와 연동하여 빌드 자동화를 통해 프로젝트 진행의 효율성을 높일 수 있습니다.</p>

<p>자동화 테스트
자동화 테스트는 젠킨스를 사용해야 하는 가장 큰 이유 중 하나이며, 사실상 자동화 테스트가 포함되지 않은 빌드는 CI자체가 불가능하다고 봐도 무방합니다. 젠킨스는 Subversion이나 Git과 같은 버전관리시스템과 연동하여 코드 변경을 감지하고 자동화 테스트를 수행하기 때문에 만약 개인이 미처 실시하지 못한 테스트가 있다 하여도 든든한 안전망이 되어줍니다. 제대로 테스트를 거치지 않은 코드를 커밋하게 되면 화난 젠킨스를 만나게 됩니다.</p>

<p>코드 표준 준수여부 검사
자동화 테스트와 마찬가지로 개인이 미처 실시하지 못한 코드 표준 준수 여부의 검사나 정적 분석을 통한 코드 품질 검사를 빌드 내부에서 수행함으로써 기술적 부채의 감소에도 크게 기여합니다.</p>

<p>빌드 파이프라인 구성
2개 이상의 모듈로 구성되는 레이어드 아키텍처가 적용 된 프로젝트에는 그에 따는 빌드 파이프라인 구성이 필요합니다. 예를 들면, 도메인 -&gt; 서비스 -&gt; UI와 같이 각 레이어의 참조 관계에 따라 순차적으로 빌드를 진행하지 않으면 안됩니다. 젠킨스에서는 이러한 빌드 파이프라인의 구성을 간단히 할 수 있으며, 스크립트를 통해서 매우 복잡한 제어까지도 가능합니다.</p>]]></content><author><name>이승호</name></author><category term="CI/CD" /><category term="Jenkins" /><category term="Pipeline" /><category term="배포자동화" /><summary type="html"><![CDATA[Jenkins]]></summary></entry><entry><title type="html">NoSQL이란?</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="NoSQL이란?" /><published>2022-06-22T00:00:00+09:00</published><updated>2022-06-22T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p>NoSQL :</p>

<p>NoSQL은 (non SQL 또는 non relational) 기존 RDBMs 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하며, 관계형 데이터 베이스의 한계를 극복하기 위한 데이터 저장소의 새로운 형태로, 수평적 확장성을 갖고 있다.</p>

<p>RDBMS가 클라이언트/서버 환경에 맞는 데이터 저장기술이라면, NoSQL은 클라우드 환경에 맞는 저장 기술이다.</p>

<p>NoSQL의 특징<br />
NoSQL은 RDBMS와는 달리 데이터 간의 관계를 정의하지 않는다.
가장 큰 특징 중 하나는 관계형 데이터 베이스인 RDBMS가 데이터의 관계를 Foreign Key 등으로 정의하고 이를 이용해 Join 등의 관계형 연산을 한다고 하면, NoSQL은 데이터 간의 관계를 정의하지 않는다. 데이터 테이블은 그냥 하나의 테이블이며 각 테이블 간의 관계를 정의하지 않고 일반적으로 테이블 간의 Join도 불가능하다.
RDBMS에 비해 훨씬 더 대용량의 데이터를 저장할 수 있다.
RDBMS의 복잡도와 용량의 한계를 극복하기 위한 목적으로 등장한 만큼 페타바이트급의 대용량 데이터를 저장할 수 있다.
분산형 구조이다.
NoSQL은 기존 RDBMS와는 다르게 하나의 고성능 머신에 데이터를 저장하는 것이 아니라 일반적인 서버 수십 대를 연결해 데이터를 저장 및 처리하는 구조를 갖는다. 즉 분산형 구조를 통해 데이터를 여러 대의 서버에 분산해 저장하고 분산 시에 데이터를 상호 복제해 특정 서버에 장애가 발생했을 때에도 데이터 유실이나 서비스 중지가 없는 구조의 형태를 가진다.
고정되지 않은 테이블 스키마를 갖는다.
RDBMS와는 다르게 테이블의 스키마가 유동적이다. 데이터를 저장하는 컬럼은 각기 다른 이름과 다른 데이터 타입을 갖는 것이 허용된다.
스키마란? 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.
RDBMS 와 NoSQL의 차이
RDBMS
장점</p>

<ul>
  <li>DATA를 Column과 Row 형태로 저장</li>
  <li>데이터의 분류, 정렬, 탐색 속도가 비교적 빠름</li>
  <li>SQL 이라는 구조화 된 질의를 통해 데이터를 다룰 수 있음</li>
  <li>작업의 완전성을 보장
단점</li>
  <li>데이터의 UPDATE가 빠르다</li>
  <li>반드시 스키마 규격에 맞춰서 데이터를 다뤄야 한다.</li>
  <li>
    <p>데이터 처리에 대한 부하 발생시, 처리가 어렵다.
NoSQL
장점</p>
  </li>
  <li>데이터간의 관계를 정의 하지 않는다(테이블 간의 관계(JOIN) 불필요)</li>
  <li>RDBMS 보다 복합도가 떨어져, 훨씬 대용량의 데이터를 저장, 관리 할 수 있다.</li>
  <li>테이블에 스키마가 정해져있지 않아 데이터 저장이 비교적 자유롭다.</li>
  <li>
    <p>수평적 확장이 어려운 RDBMS보다는 수평적 확장이 쉽다.
단점</p>
  </li>
  <li>스키마가 정해져 있지 않아, 데이터에 대한 규격화가 되어있지 않음.</li>
  <li>DATA를 UPDATE하는데 비교적 느림</li>
  <li>중복된 데이터가 저장될 수 있다.</li>
</ul>

<p>NoSQL에 대한 오해
NoSQL이 등장하면서 기존의 RDBMS의 단점들이 부각되기는 하지만 여전히 RDMB의 성능과 기능은 뛰어나다.</p>

<p>설정과 튜닝을 통해서 NoSQL에 비해 원하는 성능과 확장성을 충분히 갖추고 있다.</p>

<p>NoSQL을 검토할때는 3가지 측면을 고려한다.</p>

<p>데이터의 규모와 데이터의 처리속도 그리고 데이터의 형태이다.</p>

<p>많은 데이터와 빠른 속도로 데이터를 처리하는 것을 다 만족하는 데이터베이스는 없습니다.</p>

<p>인메모리 기반의 데이터베이스는 당연히 속도가 빠르겠지만 확장성에 있어서 한계가 있기 때문에 수십테라바이트, 수백테라바이트의 빅데이터를 다루기에는 적합하지 않습니다.</p>

<p>반면, 빅데이터를 처리하는 경우에는 상대적으로 읽기/쓰기/업데이트등의 성능 및 기능의 제약이 존재합니다.</p>

<p>데이터의 복잡도에 따라서 성능의 차이가 발생하게 됩니다. 단순한 작은 크기의 값을 다루는 key/value 인 경우에는 그 성능이 매우 뛰어난 데이터베이스더라도 처리하는</p>

<p>value의 데이터 크기가 좀 커지고 복잡해지면 성능이 떨어지는 경우도 있지만 NoSQL의 경우에는 좀 더 복잡한 데이터 구조를 수용하면서도 성능을 어느정도 보장해주는것이 있다.</p>

<p>NoSQL들을 보면 메모리를 많이 사용해서 성능도 향상시키면서 확장성도 어느 정도갖추도록 아키텍쳐들이 개선되어 가고 있지만 이를 위해서 필요한 서버의 성능도 올라가야합니다.</p>

<p>이를 위해 서버의 비용도 부담이 되기 때문에 이점도 고려를 해야하는 사항입니다.</p>]]></content><author><name>이승호</name></author><category term="몽고DB" /><category term="NoSQL" /><category term="Blog" /><summary type="html"><![CDATA[몽고DB야 안녕!]]></summary></entry><entry><title type="html">백엔드 개발자 첫 출근 후기 (feat. Node js)</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="백엔드 개발자 첫 출근 후기 (feat. Node js)" /><published>2022-06-21T00:00:00+09:00</published><updated>2022-06-21T00:00:00+09:00</updated><id>http://localhost:4000/til</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">아마 생활코딩님이 없었다면 지금의 나도 없지 않을까?</code><br />
코딩이라는 것에 관심이 있었지만<br />
만약 생활코딩님의 입문자들을 위한 영상이 없었더라면,,
입문하기 어렵다는 이유로 개발을 시작하지 않았을지도 모른다.</p>

<p>그렇게 개발 공부를 하면서<br />
사실 직장을 가지게 될 것이라고는 생각하지 않았었다.</p>

<p>그저 재미로 시작한 것일 뿐인데<br />
하다보니 내 생활이 되고 점점 개발은 내게 스며들어왔다.</p>

<p>서론이 너무 길었다!</p>

<p>백엔드 개발자로 이틀을 출근했다.<br />
출근 전 머릿속으로 어떤 모습일지 어떻게 일하게 될 지<br />
상상하고 즐겁게 출근했는데 ㅎㅎ</p>

<p>첫 날은 가자마자 같이 일하게 될 동료분들과 인사를 나누고<br />
포맷된 아이맥 앞에 앉았다.<br />
맥북은 계속 써봤지만 아이맥을 막상 보니 커다란 맥북을 보는 기분이었다.</p>

<p>포맷된 아이맥으로 개발 환경 세팅을 했다.<br />
vscode부터 시작해서 mongodb, postman, webstorm까지<br />
그리고 협업을 위한 슬랙, 깃헙, 지라, 회사 개인 계정을 지급받았다.</p>

<p>아직 회사 내 개발이 어떻게 돌아가는지 잘 모르기 때문에 사실 도메인 이해가 먼저고,<br />
이제 막 도메인이 어떻게 돌아가는지 파악하고있다~~</p>

<p>그래도 node js로 이루어진 백엔드 파트여서 다행이다 싶다가도<br />
몽고DB로 이루어진 DB파트를 보며 알아갈게 생겨서 재밌겠다!라는 생각도 들었다ㅎㅎ</p>

<p>고작 이틀 지났지만 대표님과 회사 동료분들의 인상이 다들 참 좋으시다.<br />
나이대도 나와 비슷해서 친근한 느낌마저 든다 :)</p>

<p>이틀 동안 나가보니 딱 간략하게 정리하자면!!</p>

<p>회사 내 도메인 파악을 끝내고 어서 실무에 투입되서 몰입해보고 싶다!<br />
그리고 역시 공부할 때와 실제로 적용되서 비즈니스로 운영되는 코드를 보는 것은<br />
느낌 자체가 다르다.</p>

<p>실질적으로 사용성이 좋은 코드, 성능에 맞는 코드가 필요하기 때문에<br />
이제 제대로 경기장에 나온 느낌이다 ㅎㅎ</p>

<p>개발 공부를 처음 시작할 때 즈음 블로그에 기록했었던 말이 생각난다.<br />
빠르게 가는 것보다 천천히 한 걸음씩 가자!</p>]]></content><author><name>이승호</name></author><category term="개발자 블로그" /><category term="backend" /><category term="첫 출근" /><category term="Blog" /><summary type="html"><![CDATA[달콤한 9개월 간의 여정]]></summary></entry><entry><title type="html">github.io 블로그 첫 포스팅 :)</title><link href="http://localhost:4000/firstPost/" rel="alternate" type="text/html" title="github.io 블로그 첫 포스팅 :)" /><published>2022-06-20T00:00:00+09:00</published><updated>2022-06-20T00:00:00+09:00</updated><id>http://localhost:4000/firstPost</id><content type="html" xml:base="http://localhost:4000/firstPost/"><![CDATA[<p>내가 사이트로 블로그를 만들다니 너무 신기하다 :)<br />
깃허브 블로그 만드는데 수많은 오류를 만났다,,<br />
그래도 구글링덕분에 잘 해결된 것 같다!<br />
일단 나만의 공간이 생겼으니 자질구레한 것이라도 기록하자 😆<br />
remember!!!<br />
 <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code></p>]]></content><author><name>이승호</name></author><category term="Blog" /><summary type="html"><![CDATA[Github Blog 게시글 테스트]]></summary></entry></feed>